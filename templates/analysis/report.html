{% extends 'base.html' %}

{% block title %}
{% if platform == 'chess.com' %}
Chess.com Analysis Report for {{ username }} - Chess Analysis
{% else %}
Lichess Analysis Report for {{ username }} - Chess Analysis
{% endif %}
{% endblock %}

{% block content %}
<div class="simple-report">
    {% load static %}
    <div class="report-header" style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
        {% if platform == 'chess.com' %}
            <img src="{% static 'images/chess_com_logo.png' %}" alt="Chess.com" style="height: 40px; width: auto;">
            <h1 style="margin: 0;">Chess.com Analysis Report for {{ username }}</h1>
        {% else %}
            <img src="{% static 'images/lichess_logo.svg' %}" alt="Lichess" style="height: 40px; width: auto;">
            <h1 style="margin: 0;">Lichess Analysis Report for {{ username }}</h1>
        {% endif %}
    </div>

    {% if auto_start %}
    <!-- Analysis Progress Section -->
    <div id="analysis-progress" style="margin: 20px 0; padding: 20px; border-left: 4px solid #007bff;">
        <h2>ðŸ”„ Analysis Progress</h2>
        <div id="progress-status">Initializing analysis...</div>
        <div id="progress-bar" style="background: #e0e0e0; height: 20px; border-radius: 10px; margin: 10px 0;">
            <div id="progress-fill" style="background: #007bff; height: 100%; width: 0%; border-radius: 10px; transition: width 0.3s;"></div>
        </div>
    </div>
    {% endif %}

    <h2 style="margin-top: 40px; margin-bottom: 10px;">Filters</h2>
    <div id="game-filters" class="game-filters" style="display: flex; flex-direction: column; align-items: center;">
        <div style="margin-bottom: 16px; width: 100%; max-width: 600px;">
            <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-primary); text-align: center;">Color:</div>
            <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                <button id="filter-all" class="filter-btn filter-btn-active" data-filter="all">
                    All
                </button>
                <button id="filter-white" class="filter-btn" data-filter="white">
                    White
                </button>
                <button id="filter-black" class="filter-btn" data-filter="black">
                    Black
                </button>
            </div>
        </div>
        <div style="margin-bottom: 16px; width: 100%; max-width: 600px;">
            <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-primary); text-align: center;">Time Control:</div>
            <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                <button id="speed-filter-all" class="filter-btn filter-btn-active" data-speed="all">
                    All
                </button>
                <div id="speed-filter-buttons" style="display: contents;">
                    <!-- Speed filter buttons will be dynamically added here -->
                </div>
            </div>
        </div>
        <div style="text-align: center;">
            <span id="filter-status" style="color: var(--text-secondary); font-size: 14px;">
                All games loaded
            </span>
        </div>
    </div>

    <h2 style="margin-top: 40px; margin-bottom: 10px;">Game Results Chart:</h2>
    <div id="game-results-chart-container" data-username="{{ username }}" >
        <!-- React GameResultsChart will be mounted here -->
    </div>

    <h2 style="margin-top: 40px; margin-bottom: 10px;">Mistakes Analysis Chart:</h2>
    <div id="mistakes-analysis-chart-container" data-username="{{ username }}" >
        <!-- React MistakesAnalysisChart will be mounted here -->
    </div>

    <h2 style="margin-top: 40px; margin-bottom: 10px;">Opening Analysis:</h2>
    <div id="opening-analysis-container" data-username="{{ username }}" >
        <!-- React OpeningAnalysis will be mounted here -->
    </div>

    <h2 style="margin-top: 40px; margin-bottom: 10px;">Blunder Analysis:</h2>
    <div id="blunder-analysis-container" data-username="{{ username }}" >
        <!-- React BlunderAnalysis will be mounted here -->
    </div>

    <h2 style="margin-top: 40px; margin-bottom: 10px;">Time Analysis:</h2>
    <div id="time-analysis-container" data-username="{{ username }}" >
        <!-- React TimeAnalysis will be mounted here -->
    </div>

    <h2 style="margin-top: 40px; margin-bottom: 10px;">Principles Summary:</h2>
    <div id="principles-summary-container">
        <!-- React PrinciplesSummary will be mounted here -->
    </div>

    <h2 style="margin-top: 40px; margin-bottom: 10px;">Custom Training Puzzles:</h2>
    <div id="custom-puzzles-container">
        <!-- React CustomPuzzles will be mounted here -->
    </div>

    <!-- Hidden element to store stockfish_analysis data for React components -->
    <div id="stockfish-analysis" style="display: none;">{{ stockfish_analysis|safe }}</div>

    <!-- Hidden element to store custom puzzles data for React components -->
    <div id="custom-puzzles-data" style="display: none;">{{ custom_puzzles|safe }}</div>

    <h2 style="margin-top: 40px; margin-bottom: 10px; cursor: pointer; user-select: none;" onclick="toggleRawGameData()">
        <span id="raw-game-data-toggle">â–¶</span> Raw Game Data (All Games)
    </h2>
    <pre id="raw-game-data" style="display: none; background: #222; color: #fff; padding: 20px; overflow: auto; max-height: 400px; margin: 20px 0;">{{ all_games_raw|safe }}</pre>

    <h2 style="margin-top: 40px; margin-bottom: 10px; cursor: pointer; user-select: none;" onclick="toggleEnrichedGamesData()">
        <span id="enriched-games-toggle">â–¶</span> Enriched Games Data
    </h2>
    <pre id="enriched-games" style="display: none; background: #2d1b69; color: #fff; padding: 20px; overflow: auto; max-height: 600px; margin: 20px 0;">{{ enriched_games|safe }}</pre>

    <script>
    function toggleRawGameData() {
        const pre = document.getElementById('raw-game-data');
        const toggle = document.getElementById('raw-game-data-toggle');
        if (pre.style.display === 'none') {
            pre.style.display = 'block';
            toggle.textContent = 'â–¼';
        } else {
            pre.style.display = 'none';
            toggle.textContent = 'â–¶';
        }
    }

    function toggleEnrichedGamesData() {
        const pre = document.getElementById('enriched-games');
        const toggle = document.getElementById('enriched-games-toggle');
        if (pre.style.display === 'none') {
            pre.style.display = 'block';
            toggle.textContent = 'â–¼';
        } else {
            pre.style.display = 'none';
            toggle.textContent = 'â–¶';
        }
    }
    </script>

    <!-- Hidden element for report username -->
    <span id="report-username" style="display: none;">{{ username }}</span>
</div>

<script>
let eventSource;

function startStreaming() {
    const username = "{{ username }}";

    document.getElementById('progress-status').innerText = 'Connecting to analysis monitor...';

    // Start Server-Sent Events to monitor background task
    const platform = "{{ platform|default:'lichess' }}";
    const datasetId = "{{ dataset_id }}";
    const streamUrl = `/stream-analysis/${username}/${datasetId}/`;

    eventSource = new EventSource(streamUrl);

    eventSource.onmessage = function(event) {
        const data = JSON.parse(event.data);
        handleAnalysisUpdate(data);
    };

    eventSource.onerror = function(event) {
        console.error('SSE error:', event);
        document.getElementById('progress-status').innerText = 'Error: Connection lost';
    };
}

// Auto-start if flag is set
document.addEventListener('DOMContentLoaded', function() {
    {% if auto_start %}
    startStreaming();
    {% endif %}

    // Initialize filter system
    initializeFilters();
});

function initializeFilters() {
    // Get the filter manager from the global scope (imported via the main.js bundle)
    if (typeof window.gameFilterManager === 'undefined') {
        console.log('Waiting for gameFilterManager to load...');
        setTimeout(initializeFilters, 100);
        return;
    }

    const filterManager = window.gameFilterManager;
    const username = "{{ username }}";

    // Set username for filtering
    filterManager.setUsername(username);

    // Get filter buttons
    const allBtn = document.getElementById('filter-all');
    const whiteBtn = document.getElementById('filter-white');
    const blackBtn = document.getElementById('filter-black');
    const speedAllBtn = document.getElementById('speed-filter-all');
    const speedButtonsContainer = document.getElementById('speed-filter-buttons');
    const statusSpan = document.getElementById('filter-status');

    // Store speed filter buttons for later reference
    let speedFilterButtons = [];

    // Add click handlers for color filter buttons
    if (allBtn) {
        allBtn.addEventListener('click', function() {
            setActiveColorFilter('all', allBtn);
            filterManager.setFilter('all');
        });
    }

    if (whiteBtn) {
        whiteBtn.addEventListener('click', function() {
            setActiveColorFilter('white', whiteBtn);
            filterManager.setFilter('white');
        });
    }

    if (blackBtn) {
        blackBtn.addEventListener('click', function() {
            setActiveColorFilter('black', blackBtn);
            filterManager.setFilter('black');
        });
    }

    // Add click handler for "All Speeds" button
    if (speedAllBtn) {
        speedAllBtn.addEventListener('click', function() {
            // Reset to 'all' speeds
            filterManager.setSpeedFilter('all');
            updateSpeedButtonStates();
        });
    }

    // Function to update active color filter button state
    function setActiveColorFilter(filterType, activeButton) {
        // Remove active class from all color filter buttons
        [allBtn, whiteBtn, blackBtn].forEach(btn => {
            if (btn) btn.classList.remove('filter-btn-active');
        });

        // Add active class to clicked button
        activeButton.classList.add('filter-btn-active');

        // Update status text
        if (statusSpan) {
            statusSpan.textContent = filterManager.getFilterDescription();
        }
    }

    // Function to update speed button states based on current filter
    function updateSpeedButtonStates() {
        const currentFilter = filterManager.getCurrentSpeedFilter();

        // Update "All Speeds" button
        if (speedAllBtn) {
            if (currentFilter === 'all') {
                speedAllBtn.classList.add('filter-btn-active');
            } else {
                speedAllBtn.classList.remove('filter-btn-active');
            }
        }

        // Update individual speed buttons
        speedFilterButtons.forEach(btn => {
            const speed = btn.dataset.speed;
            if (filterManager.isSpeedSelected(speed)) {
                btn.classList.add('filter-btn-active');
            } else {
                btn.classList.remove('filter-btn-active');
            }
        });

        // Update status text
        if (statusSpan) {
            statusSpan.textContent = filterManager.getFilterDescription();
        }
    }

    // Function to rebuild speed filter buttons
    function rebuildSpeedFilterButtons(availableSpeeds) {
        if (!speedButtonsContainer) return;

        // Clear existing buttons
        speedButtonsContainer.innerHTML = '';
        speedFilterButtons = [];

        // Create a button for each available speed
        availableSpeeds.forEach(speed => {
            const btn = document.createElement('button');
            btn.className = 'filter-btn';
            btn.dataset.speed = speed;
            btn.textContent = speed.charAt(0).toUpperCase() + speed.slice(1);

            btn.addEventListener('click', function() {
                // Toggle this speed in the filter
                filterManager.toggleSpeed(speed);
                updateSpeedButtonStates();
            });

            speedButtonsContainer.appendChild(btn);
            speedFilterButtons.push(btn);
        });

        // Update button states after rebuilding
        updateSpeedButtonStates();
    }

    // Listen for filter changes from the filter manager
    filterManager.addListener(function(event) {
        // Update status text
        if (statusSpan) {
            statusSpan.textContent = filterManager.getFilterDescription();
        }

        // Rebuild speed filter buttons if speeds have changed
        if (event.availableSpeeds) {
            rebuildSpeedFilterButtons(event.availableSpeeds);
        } else {
            // Just update button states if speeds haven't changed
            updateSpeedButtonStates();
        }
    });
}

// Track enriched games as they complete
let enrichedGamesArray = [];
let totalExpectedGames = 0;

function handleAnalysisUpdate(data) {
    const progressStatus = document.getElementById('progress-status');
    const progressFill = document.getElementById('progress-fill');

    switch (data.type) {
        case 'init':
            // Initialize tracking variables
            enrichedGamesArray = [];
            totalExpectedGames = data.total_games || 0;

            if (data.task_status) {
                // From task monitoring
                progressStatus.innerText = `Task started - ${data.task_status}`;
            } else if (data.message) {
                // From streaming analysis
                progressStatus.innerText = data.message;
            } else {
                // Fallback
                const totalPositions = data.total_positions || 0;
                progressStatus.innerText = `Found ${totalPositions} positions to evaluate`;
            }

            // Initialize the enriched games display
            updateEnrichedGamesDisplay();
            break;

        case 'api_progress':
            const completed = data.completed_calls || 0;
            const total = data.total_calls || 1;
            const progress = Math.round((completed / total) * 100);

            progressFill.style.width = progress + '%';
            progressStatus.innerText = `${data.current_phase} - ${progress}% (${completed}/${total})`;
            break;

        case 'game_complete':
            // Add the completed game to our array
            if (data.game_data) {
                enrichedGamesArray.push(data.game_data);

                // Update the display immediately
                updateEnrichedGamesDisplay();

                // Update progress status to show game completion
                const completedGames = data.completed_games || enrichedGamesArray.length;
                const totalGames = data.total_games || totalExpectedGames;
                progressStatus.innerText = `Games completed: ${completedGames}/${totalGames} - ${data.current_phase || 'Processing...'}`;
            } else if (data.game_analysis && data.game_analysis.game) {
                // Handle the nested game structure from your streaming system
                enrichedGamesArray.push(data.game_analysis.game);

                // Update the display immediately
                updateEnrichedGamesDisplay();

                // Update progress status to show game completion
                const completedGames = data.completed_games || enrichedGamesArray.length;
                const totalGames = data.total_games || totalExpectedGames;
                progressStatus.innerText = `Games completed: ${completedGames}/${totalGames} - ${data.current_phase || 'Processing...'}`;
            }
            break;

        case 'complete':
            progressStatus.innerText = `âœ… Analysis complete! ${enrichedGamesArray.length} games processed.`;
            progressFill.style.width = '100%';

            // Final update to enriched games display
            updateEnrichedGamesDisplay();

            // Update principles summary if data is available
            if (data.stockfish_analysis && data.stockfish_analysis.principles) {
                updatePrinciplesSummary(data.stockfish_analysis.principles);
            }

            if (eventSource) {
                eventSource.close();
            }
            break;

        case 'error':
            progressStatus.innerText = `âŒ Error: ${data.error}`;
            if (eventSource) {
                eventSource.close();
            }
            break;
    }
}

function updateEnrichedGamesDisplay() {
    const enrichedGamesEl = document.getElementById('enriched-games');

    if (enrichedGamesArray.length === 0) {
        enrichedGamesEl.textContent = JSON.stringify({
            status: "Waiting for games to complete analysis...",
            completed_games: 0,
            total_expected: totalExpectedGames
        }, null, 2);
    } else {
        // Display all completed games
        enrichedGamesEl.textContent = JSON.stringify(enrichedGamesArray, null, 2);
    }

    // Update the filter manager with new games data
    if (typeof window.gameFilterManager !== 'undefined') {
        window.gameFilterManager.updateAllGames(enrichedGamesArray);
    }

    // Update both charts with the latest data
    updateCharts();
}

function updateCharts() {
    updateGameResultsChart();
    updateMistakesAnalysisChart();
    updateOpeningAnalysisChart();
    updateBlunderAnalysis();
    updateTimeAnalysis();
}

function updateGameResultsChart() {
    // Check if we have the React root and component available
    if (window.gameResultsChartRoot && window.GameResultsChart && window.React) {
        const username = document.querySelector('#report-username').textContent;

        console.log('Updating GameResultsChart with:', {
            gamesCount: enrichedGamesArray.length,
            username: username,
            sampleGame: enrichedGamesArray[0]
        });

        try {
            // Re-render the chart with updated data
            window.gameResultsChartRoot.render(
                window.React.createElement(window.GameResultsChart, {
                    enrichedGames: enrichedGamesArray,
                    username: username,
                    chartType: 'pie'
                })
            );
            console.log('GameResultsChart render successful');
        } catch (error) {
            console.error('Error rendering GameResultsChart:', error);
        }
    } else {
        console.log('GameResultsChart not ready yet:', {
            hasRoot: !!window.gameResultsChartRoot,
            hasComponent: !!window.GameResultsChart,
            hasReact: !!window.React,
            gamesArrayLength: enrichedGamesArray ? enrichedGamesArray.length : 'undefined'
        });
    }
}

function updateMistakesAnalysisChart() {
    // Check if we have the React root and component available
    if (window.mistakesAnalysisChartRoot && window.MistakesAnalysisChart && window.React) {
        const username = document.querySelector('#report-username').textContent;

        console.log('Updating MistakesAnalysisChart with:', {
            gamesCount: enrichedGamesArray.length,
            username: username,
            sampleGame: enrichedGamesArray[0]
        });

        try {
            // Re-render the chart with updated data
            window.mistakesAnalysisChartRoot.render(
                window.React.createElement(window.MistakesAnalysisChart, {
                    enrichedGames: enrichedGamesArray,
                    username: username
                })
            );
            console.log('MistakesAnalysisChart render successful');
        } catch (error) {
            console.error('Error rendering MistakesAnalysisChart:', error);
        }
    } else {
        console.log('MistakesAnalysisChart not ready yet:', {
            hasRoot: !!window.mistakesAnalysisChartRoot,
            hasComponent: !!window.MistakesAnalysisChart,
            hasReact: !!window.React,
            gamesArrayLength: enrichedGamesArray ? enrichedGamesArray.length : 'undefined'
        });
    }
}

function updateOpeningAnalysisChart() {
    // Check if we have the React root and component available
    if (window.openingAnalysisRoot && window.OpeningAnalysis && window.React) {
        const username = document.querySelector('#report-username').textContent;

        console.log('Updating OpeningAnalysis with:', {
            gamesCount: enrichedGamesArray.length,
            username: username,
            sampleGame: enrichedGamesArray[0]
        });

        try {
            // Re-render the chart with updated data
            window.openingAnalysisRoot.render(
                window.React.createElement(window.OpeningAnalysis, {
                    enrichedGames: enrichedGamesArray,
                    username: username
                })
            );
            console.log('OpeningAnalysis render successful');
        } catch (error) {
            console.error('Error rendering OpeningAnalysis:', error);
        }
    } else {
        console.log('OpeningAnalysis not ready yet:', {
            hasRoot: !!window.openingAnalysisRoot,
            hasComponent: !!window.OpeningAnalysis,
            hasReact: !!window.React,
            gamesArrayLength: enrichedGamesArray ? enrichedGamesArray.length : 'undefined'
        });
    }
}

function updateBlunderAnalysis() {
    // Check if we have the React root and component available
    if (window.blunderAnalysisRoot && window.BlunderAnalysis && window.React) {
        const username = document.querySelector('#report-username').textContent;

        console.log('Updating BlunderAnalysis with:', {
            gamesCount: enrichedGamesArray.length,
            username: username,
            sampleGame: enrichedGamesArray[0]
        });

        try {
            // Re-render the component with updated data
            window.blunderAnalysisRoot.render(
                window.React.createElement(window.BlunderAnalysis, {
                    enrichedGames: enrichedGamesArray,
                    username: username
                })
            );
            console.log('BlunderAnalysis render successful');
        } catch (error) {
            console.error('Error rendering BlunderAnalysis:', error);
        }
    } else {
        console.log('BlunderAnalysis not ready yet:', {
            hasRoot: !!window.blunderAnalysisRoot,
            hasComponent: !!window.BlunderAnalysis,
            hasReact: !!window.React,
            gamesArrayLength: enrichedGamesArray ? enrichedGamesArray.length : 'undefined'
        });
    }
}

function updateTimeAnalysis() {
    // Check if we have the React root and component available
    if (window.timeAnalysisRoot && window.TimeAnalysis && window.React) {
        const username = document.querySelector('#report-username').textContent;

        console.log('Updating TimeAnalysis with:', {
            gamesCount: enrichedGamesArray.length,
            username: username,
            sampleGame: enrichedGamesArray[0]
        });

        try {
            // Re-render the component with updated data
            window.timeAnalysisRoot.render(
                window.React.createElement(window.TimeAnalysis, {
                    enrichedGames: enrichedGamesArray,
                    username: username
                })
            );
            console.log('TimeAnalysis render successful');
        } catch (error) {
            console.error('Error rendering TimeAnalysis:', error);
        }
    } else {
        console.log('TimeAnalysis not ready yet:', {
            hasRoot: !!window.timeAnalysisRoot,
            hasComponent: !!window.TimeAnalysis,
            hasReact: !!window.React,
            gamesArrayLength: enrichedGamesArray ? enrichedGamesArray.length : 'undefined'
        });
    }
}

function updatePrinciplesSummary(principlesData) {
    // Check if we have the React root and component available
    if (window.principlesSummaryRoot && window.PrinciplesSummary && window.React) {
        console.log('Updating PrinciplesSummary with:', {
            principlesData: principlesData
        });

        try {
            // Update the hidden stockfish-analysis element for persistent storage
            const stockfishAnalysisEl = document.getElementById('stockfish-analysis');
            if (stockfishAnalysisEl) {
                stockfishAnalysisEl.textContent = JSON.stringify({ principles: principlesData });
            }

            // Re-render the component with updated data
            window.principlesSummaryRoot.render(
                window.React.createElement(window.PrinciplesSummary, {
                    principlesData: principlesData
                })
            );
            console.log('PrinciplesSummary render successful');
        } catch (error) {
            console.error('Error rendering PrinciplesSummary:', error);
        }
    } else {
        console.log('PrinciplesSummary not ready yet:', {
            hasRoot: !!window.principlesSummaryRoot,
            hasComponent: !!window.PrinciplesSummary,
            hasReact: !!window.React
        });
    }
}

function updateDisplaysWithResults(data) {
    // Fetch the actual enriched games data from the completed report
    fetchEnrichedGamesData(data.report_id);
}

function fetchEnrichedGamesData(reportId) {
    // Make a request to get the enriched games data from the completed report
    fetch(`/report-data/${reportId}/`)
        .then(response => response.json())
        .then(data => {
            const enrichedGamesEl = document.getElementById('enriched-games');
            if (data.enriched_games && data.enriched_games.length > 0) {
                enrichedGamesEl.textContent = JSON.stringify(data.enriched_games, null, 2);

                // Update both charts with final data
                enrichedGamesArray = data.enriched_games;
                updateCharts();
            } else {
                enrichedGamesEl.textContent = JSON.stringify({
                    status: "No enriched games data available",
                    report_id: reportId
                }, null, 2);
            }
        })
        .catch(error => {
            console.error('Error fetching enriched games:', error);
            const enrichedGamesEl = document.getElementById('enriched-games');
            enrichedGamesEl.textContent = JSON.stringify({
                error: "Failed to load enriched games data",
                details: error.message
            }, null, 2);
        });
}

</script>

{% load static %}
<script src="{% static 'js/dist/main.js' %}"></script>
{% endblock %}
